
#include "Board.h"

#define     ACK_LENGTH      10 
     
uint8_t       AckBuffer[ACK_LENGTH] = { 10, 11, 12, 13, 14, 15, 16, 17, 18, 19 };

void SI4463_Delay(uint32_t cnt);

/*
****************************************************
*  Function       : d_open_si4463
*  Description    : init SI4463
*  Calls          : 
*  Called By      : 
*  Input          : 
*  Output         : 
*  Return         : 
*  Others         : set the module at RX state
*  Author         : 
*****************************************************
*/
result d_open_si4463(void)
{
    //first open the SPI peripherals...
	if(spi_1.p_open() != true)return false;

	SI446X_RESET();  
    // config the module basic on the header file...the header was generated by WDS
    SI446X_CONFIG_INIT();  
    // set the power to max
    SI446X_SET_POWER(0x7F); 
     //     
    SI446X_START_RX(board.board_Local_channel, 0, PACKET_LENGTH, 8, 8, 8);    
    //
    SET_STATE(si4463.state,STATE_OPEN);
    RESET_STATE(si4463.state,STATE_CLOSE);
    
	return true;
}
/*
****************************************************
*  Function       : d_close_si4463
*  Description    : 
*  Calls          : 
*  Called By      : 
*  Input          : 
*  Output         : 
*  Return         : 
*  Others         : Nothing to do here 
*  Author         : 
*****************************************************
*/
result d_close_si4463(void)
{
    SET_STATE(si4463.state,STATE_CLOSE);
    RESET_STATE(si4463.state,STATE_OPEN);
	return true;
}
/*
****************************************************
*  Function       : d_detect_si4463
*  Description    : 检测SI4463是否存在
*  Calls          : 
*  Called By      : 
*  Input          : 
*  Output         : 
*  Return         : 
*  Others         : Nothing to do here
*  Author         : 
*****************************************************
*/
result d_detect_si4463(void)
{
    if(CHECK_STATE(si4463.state,STATE_CLOSE))
    {
        if(si4463.d_open() != true)
        {
            return false;
        }
    }
    
	return true;
}
/*
****************************************************
*  Function       : d_command_si4463
*  Description    : we can send some command to some device
*  Calls          : 
*  Called By      : 
*  Input          : 
*  Output         : 
*  Return         : 
*  Others         : Nothing to do here
*  Author         : 
*****************************************************
*/
result d_command_si4463 (uint8_t * Param1, uint32_t Param2)
{
    if(CHECK_STATE(si4463.state,STATE_CLOSE))
    {
        if(si4463.d_open() != true)
        {
            return false;
        }
    }
	
	Param1 = Param1;
	Param2 = Param2;

	return true;
}


/*
****************************************************
*  Function       : d_set_si4463
*  Description    : 
*  Calls          : 
*  Called By      : 
*  Input          : 
*  Output         : 
*  Return         : 
*  Others         : Nothing to do here
*  Author         : 
*****************************************************
*/
result d_set_si4463(uint32_t Param1,uint32_t Param2)
{
    if(CHECK_STATE(si4463.state,STATE_CLOSE))
    {
        if(si4463.d_open() != true)
        {
            return false;
        }
    }
	
	Param1 = Param1;
	Param2 = Param2;

	return true;
}
/*
****************************************************
*  Function       : d_puts_si4463
*  Description    : send a block of data,if receving ACK return true,else return false.
*  Calls          : 
*  Called By      : 
*  Input          : 
						RecvAddr:the addr where the data send to,
						start:the data's start addr
						length:data's length
*  Output         : 
*  Return         : 
					
*  Others         : 
*  Author         : 
*****************************************************
*/
result d_puts_si4463(uint32_t RecvAddr,uint8_t * start,uint32_t length)
{
	uint8_t RepeatCounter = 0;
	//retry the send for 4 timers
	ReSend:
    if(CHECK_STATE(si4463.state,STATE_CLOSE))
    {
        if(si4463.d_open() != true)
        {
            return false;
        }
    }
    {
		uint8_t temp[10] = {0x00},cnt = 0,cnt1 = 0;
		//p_dataframe temp_dataframe = (p_dataframe)start;
		/***********************警告***************************/
		/*SI446X_SEND_PACKET不能实现其他频率（通道）发送，  */
		/*只能先用SI446X_START_RX修改本地频率，然后才能实现 */
		/*任意频率（通道）发送*/
		/******************************************************/
        if(SI446X_START_RX(RecvAddr, 0, PACKET_LENGTH,8, 8, 8) != true)return false;
		// 2016--10--22--11--15--27:Change the delay length here from 20 to 4
        SI4463_Delay(4);
		//inter critical mode,
        taskENTER_CRITICAL();
		if(SI446X_SEND_PACKET(start,length,RecvAddr,0) != true)return false;//发送数据
        //wait for send finish
        do{    
            if(SI446X_INT_STATUS(temp) != true || cnt++ > 200)return false;
			SI4463_Delay(1);
        }while (!(temp[3] & (1<<5))); 
		cnt = 0;
        //进入接收状态  PACKET_LENGTH
        if(SI446X_START_RX(board.board_Local_channel, 0,ACK_LENGTH  ,8, 8, 8) != true)return false;
        taskEXIT_CRITICAL();
        //osDelay(20);
        //开始检有无ACK并检查其完整性
        for(cnt = 0;cnt < 10;cnt ++)
        {
            osDelay(10);
            if(SI446X_INT_STATUS(temp) != true)return false;
            if (temp[3] & (1<<4))
            {
                length = SI446X_READ_PACKET(start);
                
                for(cnt1 = 0;cnt1 < ACK_LENGTH;cnt1 ++)
                {
                    if(start[cnt1] != AckBuffer[cnt1])return false;
                 }
                //检查通过。。。
                if(cnt1 == ACK_LENGTH)
                {
                    //进入接收状态
                    if(SI446X_START_RX(board.board_Local_channel, 0, PACKET_LENGTH,8, 8, 8) != true)return false;
                    return true;
                }
                else 
                {
                    return false;
                }
            }
        }
		//如果到达这里，说明没有等到ACK此次发送认为失败了，需要重传
		RepeatCounter ++;
        //osDelay(5);
		if(RepeatCounter >= 4)
        {
            return false;
        }
		goto ReSend;
	}
}

/*
****************************************************
*  Function       : d_gets_si4463
*  Description    : 将数据读出来
*  Calls          : 
*  Called By      : 
*  Input          : start:数据起始，length：数据长度
*  Output         : 
*  Return         : 
*  Others         : 
*  Author         : 
*****************************************************
*/
result d_gets_si4463(uint32_t SendAddr,uint8_t * start,uint32_t length)
{
    static uint8_t LastSendAddr = 0xff,cnt2 = 0;
    static uint32_t cnt = 0;
    
    length = length;
    
    cnt ++;
    if(cnt > 1000000)cnt = 0;
    
    if(CHECK_STATE(si4463.state,STATE_CLOSE) || (cnt % 10000 == 0))
    {
        if(si4463.d_open() != true)
        {
            return false;
        }
    }
    if(LastSendAddr != SendAddr || cnt % 100 == 0)
    {
        LastSendAddr = SendAddr;
        if(SI446X_START_RX(SendAddr, 0, PACKET_LENGTH,8, 8, 8) != true)return false;
    }

    {
		uint8_t temp[10] = {0x00};
		/* 检测是否收到一个数据包 */
        taskENTER_CRITICAL();
		if(SI446X_INT_STATUS(temp) != true)return false;
		if (temp[3] & (1<<4))
		{
            p_dataframe temp_dataframe = (p_dataframe)start;
            //读取数据包内容
			length = SI446X_READ_PACKET(start);
            taskEXIT_CRITICAL();
            //解密数据，出错则返回失败
            if(CRC_JIEMI((uint8_t *)start) == false)return false;
            
            //SI4463_Delay(300);
            
            //osDelay(5);
			/***********************警告***************************/
			/*SI446X_SEND_PACKET不能实现其他频率（通道）发送，  */
			/*只能先用SI446X_START_RX修改本地频率，然后才能实现 */
			/*任意频率（通道）发送*/
			/******************************************************/
            if(SI446X_START_RX(temp_dataframe->sender_channel, 0, PACKET_LENGTH,8, 8, 8) != true)return false;
            // 返回应答信号,应答数据为10-19
            if(SI446X_SEND_PACKET(AckBuffer, ACK_LENGTH,temp_dataframe->sender_channel,0) != true)return false;
            do
            {  
                //osDelay(5);
                if(SI446X_INT_STATUS(temp) != true || cnt2++ > 200)return false;
				SI4463_Delay(1);
            }while (!(temp[3] & (1<<5)));    //等待发射完成（中断产生）
            //进入接收状态
            if(SI446X_START_RX(board.board_Local_channel, 0, PACKET_LENGTH,8, 8, 8) != true)return false;
            data_recv_process();
            return true;
		}
        taskEXIT_CRITICAL();
	}

	return false;
}
/*
****************************************************
*  Function       : d_timing_proceee_si4463
*  Description    : 
*  Calls          : 
*  Called By      : 
*  Input          : 
*  Output         : 
*  Return         : 
*  Others         : 
*****************************************************
*/
result d_timing_proceee_si4463(uint32_t Interval, uint32_t Param2, uint32_t Param3)
{
	static uint32_t During = 0x00;
	
    if(CHECK_STATE(si4463.state,STATE_CLOSE))
    {
        if(si4463.d_open() != true)
        {
            return false;
        }
    }
	
	During += Interval;
	//每30分钟关闭一次
	if(During >= 10 * 60 * 1000)
	{
		During = 0;
		si4463.d_close();
	}
	
	Param2 = Param2;
	Param3 = Param3;

	return true;
}
/*
****************************************************
*  Function       : d_process_it_si4463
*  Description    : 
*  Calls          : 
*  Called By      : 
*  Input          : 
*  Output         : 
*  Return         : 
*  Others         : 
*****************************************************
*/
result d_process_it_si4463(uint32_t Param1, uint32_t Param2, uint32_t Param3)
{
    if(CHECK_STATE(si4463.state,STATE_CLOSE))
    {
        if(si4463.d_open() != true)
        {
            return false;
        }
    }
	
	Param1 = Param1;
	Param2 = Param2;
	Param3 = Param3;

	return true;
}

deviceModule si4463 = 
{
	"si4463",
	//1,
	//1,
	STATE_CLOSE,
    0x00,
	Private,
	d_open_si4463,
	d_close_si4463,
	d_detect_si4463,
    d_command_si4463,
	d_set_si4463,
	d_puts_si4463,
	d_gets_si4463,
	d_timing_proceee_si4463,
	d_process_it_si4463
};


























